# [内存分配、C++变量的生命周期和作用域](https://www.cnblogs.com/Xylophone/p/3400589.html)

问题：

+ 成员对象初始化问题，http://c.biancheng.net/view/167.html。初始化顺序

  > 1 成员变量必须要使用初始化列表进行初始化。
  >
  > 封闭类生成：1.调用成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。
  >
  > 当封闭类对象消亡时：先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构，这是 [C++](http://c.biancheng.net/cplus/) 处理此类次序问题的一般规律。
  >
  > 2. 因此一般成员对象需要有默认构造函数。
  > 3. 封闭类复制构造函数，如果是用默认复制构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。例如下而的程序

# 1、在main执行之前和之后执行的代码可能是什么？

**main函数执行之前**，主要就是初始化系统相关资源：

+ 设置栈指针
+ **静态变量和全局变量**：初始化静态`static`变量和`global`全局变量，即`.data`段的内容
+ **全局变量赋初值**：将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容     
+ **全局对象构造函数**，在`main`之前调用构造函数，这是可能会执行前的一些代码
+ **传递参数**：将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
+ `__attribute__((constructor))`：执行由前修饰的函数

**main函数执行之后**： 释放系统相关资源 

+ **全局对象的析构函数**：会在main函数之后执行； 
+ 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
  + atexit：设置程序正常结束前调用的函数
+ `__attribute__((destructor))`：执行由前修饰的函数

>update1:https://github.com/forthespada/InterviewGuide/issues/2 ,由`stanleyguo0207`提出 - 2021.03.22

# 2、结构体内存对齐问题？

参考https://blog.csdn.net/qq_37858386/article/details/75909852

- **首字母地址**：结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- **对齐长度**：未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

c++11以后引入两个关键字 [alignas](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof](https://zh.cppreference.com/w/cpp/language/alignof)。

+ 其中`alignof`可以计算出类型的对齐方式，
+ `alignas`可以指定结构体的对齐方式。

## 空结构体和空类

空类和空结构体占用一个字节：

+ **空类和空结构体也可以实例化**，每个实例有独一无二地址，编译器给空类或者空结构体隐含加上一个字节。

## 普通结构体

+ 当前成员变量的偏移量必须是成员大小的整数倍
+ 结构体的大小必须是所有成员大小的整数倍，其实就是最大成员大小的整数倍
  + char int char  一共占用12字节
  + char char int 一共占用8字节

## 嵌套结构体

+ 被展开结构体的第一个成员的偏移量是被展开结构体的最大成员的整数倍

  short  struct{char int} int    其中char 的偏移量是4 而不是2

+ 结构体的大小，是所有成员大小的整数倍（结构体需要展开，不能看成一个成员）

# 3、指针和引用的区别

- **定义**：指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- **嵌套**：指针可以有多级，引用只有一级
- **初始化**：
  + 指针可以为空（存在指向NULL的指针），引用不能为NULL（必须有具体实体）且在定义时必须初始化
  + 指针在初始化后可以改变指向，而引用在初始化之后不可再改变（指针常量）
  + 引用在声明时必须初始化（声明定义一起），指针声明和定义可以分离
- **大小**：sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- **参数传递**：当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 内存：引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。

**引用本质：自动转换为指针和自动解引用**. 在编译器看来, int a = 10; int &amp;b = a; 等价于 int * const b = &amp;a; 而 b = 20; 等价于 *b = 20; 

# 4、堆和栈的区别（五点）

- **申请方式不同**。

  - 栈由系统自动分配。
  - 堆是自己申请和释放的。

- 申请大小限制不同。

  **内存**：

  +  **空间大小和生长方向**：
     + 栈空间默认是4M（系统自动分配）（连续区域）（向地址扩展）, 
     + 堆区一般是 1G - 4G（受限于操作系统位数）（不连续区域） （向高地址扩展）

  - **碎片问题**：堆（不连续空间）会产生碎片，栈（连续空间）不产生碎片。
  - **分配方式**：
    + 堆：动态分配：系统记录空闲内存地址的链表，寻找节点，删除节点分配空间，插入节点，收回空间
    + 栈：静态分配（编译器完成，局部变量分配），动态分配（allot函数分配你完成）。系统自动分配，超过剩余大小，栈溢出

- **申请效率不同**。

  - 栈由系统分配，速度快，不会有碎片。

  - 堆由程序员分配，速度慢，且会有碎片。


|                  | 堆                                                           | 栈                                                           |
| :--------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删    除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit  系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在  编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。    | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门  寄存器存放栈地址，栈操作有专门指令。 |

**形象的比喻**

栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。

> 《C++中堆（heap）和栈(stack)的区别》：https://blog.csdn.net/qq_34175893/article/details/83502412

# 5、区别以下指针类型？

```
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- int *p[10]表示**指针数组**，（**存放指针的数组**），强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。

- int (*p)[10]表示**数组指针**（**指向数组的指针**），强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。

- int *p(int)是**函数声明**，函数名是p，参数是int类型的，返回值是int *类型的。

- int (*p)(int)是**函数指针**，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

# 6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

+ 虚函数表：C++中**虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；**

+ 虚函数：**而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。** 
+ 虚表指针：对象内存中

首先整理一下虚函数表的特征：

- **出现时间：**在编译时就构造完成，虚函数表是全局共享的元素，即全局仅有一个，

- **存放内容**：虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

- 虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，**虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区**，测试结果显示：

**vptr出现时间:**vptr相当于类的成员变量，存储在对象内存中。因此在类初始化实例对象时，vptr初始化。

> 《虚函数表存放在哪里》：https://blog.csdn.net/u013270326/article/details/82830656

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区



# 7、new / delete 与 malloc / free的异同

**相同点**

- 都可用于内存的动态申请和释放

**不同点**

- **运算符VS库函数**：前者是C++运算符，后者是C/C++语言标准库函数
- **大小计算**：new自动计算要分配的空间大小，malloc需要手工计算
- **类型检查：**new是类型安全的，malloc不是。例如：

```C++
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
```

*  new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象 
*  后者需要库文件支持，前者不用

# 8、new和delete是如何实现的？

- new的实现过程是：
  + **分配内存**：首先调用名为**operator new**的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；
  + **构造函数**：接下来运行该类型的一个构造函数，用指定初始化构造对象；
  + 返回指针：最后返回指向新分配并构造后的的对象的指针
- delete的实现过程：
  + 析构函数：对指针指向的对象运行适当的析构函数；
  + 释放内存：然后通过调用名为**operator delete**的标准库函数释放该对象所用内存

# 9、malloc和new的区别？

- **库函数vs运算符**：malloc和free是标准库函数，**支持覆盖**；new和delete是运算符，并且**支持重载**。
- **内存分配vs成员创建**：
  + **内存分配：**malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；
  + **内存分配+对象创建**：new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- **返回指针**：
  + malloc和free返回的是**void类型指针**（必须进行类型转换），
  + new和delete返回的是**具体类型指针**。

#### 9.1、delete和delete[]区别？(补充)

- **一次调用**：delete只会调用一次析构函数。
- **多次调用**：delete[]会调用数组中每个元素的析构函数。

# 10、宏定义和函数有何区别？

- **使用时期：**
  
  + **编译时期代码替换**：宏在编译时完成字符串替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；
  + **运行时期代码跳转**：函数调用在运行时需要跳转到具体调用函数。
  
- **返回值**：宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。

- **参数类型**：宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。

  `　area=S(3,2)；第一步被换为area=a*b; ，第二步被换为area=3*2;`

- 宏定义不要在最后加分号。

# 11、宏定义和typedef区别？

- **用途**：宏主要用于**定义常量及书写复杂的内容（字符串替换）**；typedef主要用于**定义类型别名**。

- **时机**：宏替换发生在（**预处理阶段**）编译阶段之前，属于文本插入替换；typedef是**编译**的一部分。

- **类型检查**：宏不检查类型；typedef会检查数据类型。

- **是否语句**：宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

# 23、define宏定义和const的区别

**执行时机**

- define是在编译的**预处理**阶段起作用，而const是在编译、运行的时候起作用

**类型检查**

- define 类型做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
- const常量有数据类型，编译器可以对其进行类型安全检查

**内存备份**

+ 宏定义的数据没有分配内存空间，只是插入替换掉；
+ const定义的变量只是值不能改变，但要分配内存空间。

# 24、C++中const和static的作用

## **static**

- 不考虑类的情况

  - **全局变量和函数隐藏**。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
  - **默认初始化为0**，包括未初始化的全局静态变量与局部静态变量，都存在**全局未初始化区**
  - **局部静态变量**：静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，
    + 其作用范围与局部变量相同，
    + 生存周期：函数退出后仍然存在，但不能使用

- 考虑类的情况

  - static成员变量：
    + **（对象共享）**只与类关联，不与类的对象关联。
    + **内存**：位于全局区**，**编译时并类外初始化后分配内存（和成员变量的区别）。
    + **类中声明，类外初始化（不标记static）**
    + **访问方式：**静态成员变量既可以通过对象名访问，也可以通过类名访问，可以由普通成员函数访问，也有static函数访问

  + static成员函数：
    + 不具有this指针，无法访问类对象的非static成员变量和非static成员函数；
    + **不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问

## **const**

- 不考虑类的情况

  - 定义：const常量在定义时必须初始化，之后无法更改

  - 初始化：const形参可以接收const和非const类型的实参，例如

    ```C++
    // i 可以是 int 型或者 const int 型
    void fun(const int& i){
    	//...
    }
    ```

- 考虑类的情况

  - const成员变量：**不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化**，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
  - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

# 12、变量声明和定义区别？

- **内存分配**：
  + 声明：编译阶段：仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；`extern int a`
  + 定义：运行阶段：要在定义的地方为其分配存储空间。`int a;`
- **多处声明单次定义**：相同变量可以在多处声明（外部变量extern），但只能在一处定义。

# 13、哪几种情况必须用到初始化成员列表？

- **常成员**：初始化一个const成员变量。

- **引用成员**：初始化一个reference成员变量。

- **基类初始化**：用一个基类的构造函数，而该函数有一组参数。

- **成员对象初始化：**调用一个数据成员对象的构造函数，而该函数有一组参数。

# 14、sizeof和strlen区别？

- **运算符VS函数**，**编译VS运行**：
  + sizeof是运算符，并不是函数，**结果在编译时得到而非运行中获得**；
  + strlen是字符处理的库函数。
- **参数不同**：
  + sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；
  + strlen的参数只能是**字符指针且结尾是'\0'的字符串**。
- ==因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。==

~~~cpp
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
~~~

# 15、常量指针和指针常量区别？

+ 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。

+ 指针常量（**常指针**）是一个不能给改变指向的指针。指针是个常量，不能中途改变指向，如int *const p。

# 16、a和&a有什么区别？

```
假设数组int a[10];
int (*p)[10] = &a;
```

- **a是数组名，是数组首元素地址**，**+1表示地址值加上一个int类型的大小**，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
- **&a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针）**，**其加1时，系统会认为是数组首地址加上整个数组的偏移**（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。

# 17、数组名和指针（这里为指向数组首元素的指针）区别？

同：

- **访问方法一样**：二者均可通过增减偏移量来访问数组中的元素。

不同：

- **没有自增自减**：数组名不是真正意义上的指针，可以理解为**指针常量**，所以数组名没有自增、自减等操作。
- **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。**

# 18、野指针和悬空指针

  定义：都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

  + 野指针   指的是没有被初始化过的指针
  + 悬空指针    指针最初指向的内存已经被释放了的一种指针。

## 产生原因及解决办法：

+ 野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

+ 悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空（使用智能指针）

```cpp
int main(void) { 
    
    int* p;     // 未初始化
    std::cout<< *p << std::endl; // 未初始化就被使用
    
    return 0;
}
```

因此，为了防止出错，对于指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。

  + 悬空指针

    ```cpp
    int main(void) { 
      int * p = nullptr;
      int* p2 = new int;  
      p = p2;
      delete p2;
    }
    ```
    
    此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。

# （继续看）19、遍历过程中，迭代器失效的情况

以vector为例：

**插入元素：**

1、尾后插入：

+ size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），
+ size == capacity时，所有迭代器均失效（需要重新分配空间）。

2、中间插入：

+ size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，
+ size == capacity时，所有迭代器均失效。

**删除元素：**

+ 尾后删除：只有尾迭代失效。

+ 中间删除：删除位置之后所有迭代失效。

 deque 和 vector 的情况类似, 

**list**双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器; 

**map/set**等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++); 

**unordered_(hash)** 迭代器意义不大, rehash之后, 迭代器应该也是全部失效. 

# 20、C和C++的区别

+ **面向对象**：C语言面向过程，C++面向对象
+ **命名空间：**C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等

- **内存分配**：C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- **字符串**：标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
- **输入输出**：C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
- **异常处理**：C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
- **函数重载**：C没有重载，C++有重载
  + 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。
  + 而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
- **变量定义位置：**C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的
- **引用：**在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- **布尔类型**：C语言没有布尔类型。

# 21、C++与Java的区别

**语言特性**

-  **完全面向对象**：Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强
-  **没有指针：**Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题
-  **可移植性**：
   + C++也可以在其他系统运行（.cpp->.i->.s->.o->exe），但是需要不同的编码，例如对一个数字，在windows下是大端存储，在unix中则为小端存储。
   
   + Java程序一般都是生成字节码（.class文件），在JVM里面运行得到结果。（这一点不如Java，只编写一次代码，到处运行）
   
     java运行流程：java源文件(.java)  编译器=》字节码文件(.class)  =》java解释器(java虚拟机)=>运行（二进制代码）。
-  **接口代替多继承**：Java用接口(Interface)技术取代C++程序中的多继承性。接口与多继承有同样的功能，但是省却了多继承在实现和维护上的复杂性

**垃圾回收**

- 手动回收：C++用**析构函数回收垃圾**，写C和C++程序时一定要注意内存的申请和释放
- 自动回收：Java语言不使用指针，内存的**分配和回收都是自动进行的**，程序员无须考虑内存碎片的问题

**应用场景**

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）
- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架
- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

> 《C++和java的区别和联系》：https://www.cnblogs.com/tanrong/p/8503202.html

# 22、C++中struct和class的区别

总结：除了成员属性和继承方式，完全相同

**相同点**

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，同样可以使用struct完成

**不同点**

- **成员属性**：两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的

- **继承方式**：class默认是private继承，而struct模式是public继承

  

## C++和C的struct区别

- **成员函数**：C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）
- **权限设置**：
  + C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据。
  + C++有权限设置
- **类型名使用是否加struct**：struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例

> 《struct结构在C和C++中的区别》：https://blog.csdn.net/mm_hh/article/details/70456240



# 25、C++的顶层const和底层const

**概念区分**

- **顶层**const（类似指针常量）：指的是const修饰的变量**本身**是一个常量，无法修改，指的是指针，就是 * 号的右边
- **底层**const（类似常量指针）：指的是const修饰的变量**所指向的对象**是一个常量(关键是无法通过解引用修改指向内容)，指的是所指变量，就是 * 号的左边

**举个例子**

```C++
int a = 10;
int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;        //底层const，b2本身可变，所指的对象是常量
const int b3 = 20; 		   //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;		   //用于声明引用变量，都是底层const


```

**区分作用**

- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const

  > int num_c = 3;  
  > const int *p_c = &num_c;  //p_c为底层const的指针  
  > //int *p_d = p_c;  //错误，不能将底层const指针赋值给非底层const指针  
  > const int *p_d = p_c; //正确，可以将底层const指针复制给底层const指针

- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const

> 《C++ 顶层const与底层const总结》：https://www.jianshu.com/p/fbbcf11100f6
>
> 《C++的顶层const和底层const浅析》：https://blog.csdn.net/qq_37059483/article/details/78811231

```
const int a;
int const a;
const int *a;
int *const a;
```

- int const a和const int a均表示定义常量类型a。
- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)
- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)

# 26、类的对象存储空间？

- 非静态成员的数据类型大小之和。

- 编译器加入的额外成员变量（如指向虚函数表的指针）。

- 为了边缘对齐优化加入的padding。

 空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0.

# 27、final和override关键字

+ **override**：使用override，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错
+ **final**：用于指类或函数，不需要被继承或者重写，添加final关键字后被继承或重写，编译器会报错。

## override

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```C++
class A
{
    virtual void foo();
}
class B : public A
{
    void foo(); //OK
    virtual void foo(); // OK
    void foo() override; //OK
}


```

如果不使用override，当你手一抖，将**foo()**写成了**f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：

```C++
class A
{
    virtual void foo();
};
class B : public A
{
    virtual void f00(); //OK，这个函数是B新增的，不是继承的
    virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错
};
```

## **final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：

```C++
class Base
{
    virtual void foo();
};
 
class A : public Base
{
    void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写
};

class B final : A // 指明B是不可以被继承的
{
    void foo() override; // Error: 在A中已经被final了
};
 
class C : B // Error: B is final
{
};


```

> 《C++:override和final》：https://www.cnblogs.com/whlook/p/6501918.html

# 28、复制初始化和直接初始化

- 直接初始化：**调用类的构造函数**（默认构造，普通构造，拷贝构造）
- 复制初始化：**使用=进行初始化，指定构造函数创建临时对象，拷贝构造函数拷贝临时对象**，

```C++
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数


```

- **为了提高效率，允许编译器跳过创建临时对象这一步，**直接调用构造函数构造要创建的对象，这样就完全等价于**直接初始化了**（语句1和语句3等价，2和4等价），但是需要辨别两种情况不一样。

  - 当拷贝构造函数为private时：语句3和语句4在编译时会报错

  - 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

    > **必须显示调用**：C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的

> C++的直接初始化与复制初始化的区别：https://blog.csdn.net/qq936836/article/details/83450218

# 29、初始化和赋值的区别

- 对于简单类型来说，初始化和赋值没什么区别
- 对于类和复杂数据类型来说，这两者的区别就大了，举例如下：
  + 初始化：复制初始化，普通初始化创建临时对象，拷贝初始化赋值
  + 赋值：直接使用重载=运算符。

```C++
class A{
public:
    int num1;
    int num2;
public:
    A(int a=0, int b=0):num1(a),num2(b){};
    A(const A& a){};
    //重载 = 号操作符函数
    A& operator=(const A& a){
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main(){
    A a(1,1);
    A a1 = a; //拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
    return 0;
}
```

# 30、extern"C"的用法

**extern "C"**：为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；

哪些情况下使用extern "C"：

（1）C++代码中调用C语言代码；

（2）在C++中的头文件中使用；

（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

举个例子，C++中调用C代码：

```C++
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__

extern "C"{
    typedef unsigned int result_t;
    typedef void* my_handle_t;
    
    my_handle_t create_handle(const char* name);
    result_t operate_on_handle(my_handle_t handle);
    void close_handle(my_handle_t handle);
}


```

- 参考的blog中有一篇google code上的文章，专门写extern "C"的，有兴趣的读者不妨去看看

> 《extern "C"的功能和用法研究》：https://blog.csdn.net/sss_369/article/details/84060561

+ C语言：外部函数只能声明为extend，并只放在.h文件中
+ C++：外部声明使员工extern C ，全部文件放于cpp相关的文化或者头文件中

（1）C++调用C函数：

```c++
//xx.h
extern int add(...)

//xx.c
int add(){
    
}

//xx.cpp
extern "C" {
    #include "xx.h"
}
```

（2）C调用C++函数

```c
//xx.h
extern "C"{
    int add();
}
//xx.cpp
int add(){
    
}
//xx.c
extern int add();
```

# 31、模板函数和模板类的特例化

**引入原因**

+ 编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，
+ 但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化

**定义**

对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

## **（1）模板函数特例化**

+ 使用template<>，不提供模板类型，而是给出所有具体实参
+ 本质：实例化一个模板，而不是重载模板函数。
+ 参数匹配：参数匹配都以最佳匹配为原则
  + compare(3,5)，则调用普通的模板
  + compare(“hi”,”haha”)则调用**特例化版本**.
+ 模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

```C++
template<typename T> //模板函数
int compare(const T &v1,const T &v2)
{
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2)
{
    return strcmp(p1,p2);
}


```

## **（2）类模板特例化**

+ 原理:类似函数模板，**不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。**对类进行特例化时，仍然用template<>表示是一个特例化版本，

```C++
template<>
class hash<sales_data>
{
	size_t operator()(sales_data& s);
	//里面所有T都换成特例化类型版本sales_data
	//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
};


```

**类模板的部分特例化**

**不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，**一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)

**可以特例化类中的部分成员函数而不是整个类**，举个例子：

```C++
template<typename T>
class Foo
{
    void Bar();
    void Barst(T a)();
};

template<>
void Foo<int>::Bar()
{
    //进行int类型的特例化处理
    cout << "我是int型特例化" << endl;
}

Foo<string> fs;
Foo<int> fi;//使用特例化
fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
fi.Bar();//特例化版本，执行Foo<int>::Bar()
//Foo<string>::Bar()和Foo<int>::Bar()功能不同


```

> 《类和函数模板特例化》：https://blog.csdn.net/wang664626482/article/details/52372789

# 32、C和C++的类型安全

 **什么是类型安全？**

+ 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。

## **（1）C的类型安全**

+ C在隐士类型转换时会报错。

  >  C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。

  + printf格式输出：输出不匹配的类型时，会报错
  + malloc函数的返回值：

  (1)pritf输出。

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1563707616406.png)

​		上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误

​		（2）malloc函数的返回值

> malloc是C中进行内存分配的函数，它的返回类型是void\*即空类型指针，
>
> + 类型无误：char\* pStr=(char\*)malloc(100\*sizeof(char))，这里明显做了显式的类型转换。
>
> + 类型有误：int\* pInt=(int*)malloc(100\*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。

## **（2）C++的类型安全**

如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：

- **new的严格类型匹配**：操作符new返回的指针类型严格与对象匹配，而不是void\*

- **模板的类型检查**：C中很多以void\*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；

- **const的引用：**引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换

- **内联函数的引用：**一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全

- **C++提供了dynamic_cast关键字，使得转换过程更加安全**，因为dynamic_cast比static_cast涉及更多具体的类型检查。

  例子1：void*进行类型转换

  例子2：第二个例子则是在两个类型指针之间进行强制转换

  例1：使用void\*进行类型转换

**保证程序的类型安全性**，应尽量避免使用空类型指针void\*，尽量不对两种类型指针做强制转换。

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1563708254043.png)

​	例2：不同类型指针之间转换

```C++
#include<iostream>
using namespace std;
 
class Parent{};
class Child1 : public Parent
{
public:
	int i;
	Child1(int e):i(e){}
};
class Child2 : public Parent
{
public:
	double d;
	Child2(double e):d(e){}
};
int main()
{
	Child1 c1(5);
	Child2 c2(4.1);
	Parent* pp;
	Child1* pc1;
 	
	pp=&c1; 
	pc1=(Child1*)pp;  // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误
	cout<<pc1->i<<endl; //输出：5
 
	pp=&c2;
	pc1=(Child1*)pp;  //强制转换，且类型发生变化，将造成错误
	cout<<pc1->i<<endl;// 输出：1717986918
	return 0;
}
```

# 33、为什么析构函数一般写成虚函数

+ **写成虚函数，动态绑定，派生类析构函数调用基类析构函数：**由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。
+ **不写成虚函数，静态绑定，调用基类析构函数**。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。

```C++
#include <iostream>
using namespace std;

class Parent{
public:
	Parent(){
		cout << "Parent construct function"  << endl;
	};
	~Parent(){
		cout << "Parent destructor function" <<endl;
	}
};

class Son : public Parent{
public:
	Son(){
		cout << "Son construct function"  << endl;
	};
	~Son(){
		cout << "Son destructor function" <<endl;
	}
};

int main()
{
	Parent* p = new Son();
	delete p;
	p = NULL;
	return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Parent destructor function


```

将基类的析构函数声明为虚函数：

```C++
#include <iostream>
using namespace std;

class Parent{
public:
	Parent(){
		cout << "Parent construct function"  << endl;
	};
	virtual ~Parent(){
		cout << "Parent destructor function" <<endl;
	}
};

class Son : public Parent{
public:
	Son(){
		cout << "Son construct function"  << endl;
	};
	~Son(){
		cout << "Son destructor function" <<endl;
	}
};

int main()
{
	Parent* p = new Son();
	delete p;
	p = NULL;
	return 0;
}
//运行结果：
//Parent construct function
//Son construct function
//Son destructor function
//Parent destructor function


```

但存在一种特例，在`CRTP`模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应
该声明为虚函数，因为这种继承方式，不需要虚函数表。

> update1:https://github.com/forthespada/InterviewGuide/issues/2 ,由`stanleyguo0207`提出 - 2021.03.22

# 34、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？

## 析构函数：

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。

  > 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。

- **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

## 构造函数：

- **构造函数不能定义为虚函数。**对象没有构造好，无法通过vptr找到vtable。虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。
- **但是在构造函数中可以调用虚函数**，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好

>update1:https://github.com/forthespada/InterviewGuide/issues/2 ,由`stanleyguo0207`提出 - 2021.03.22

# 35、C++中的重载、重写（覆盖）和隐藏的区别

## （1）重载（overload）

+ 范围：统一作用域下：
+ 方式：函数名相同，参数类型和数目有所不同，常函数，常引用和非常引用。无法通过返回类型重载。
  + 注意：重载和函数成员是否是虚函数无关（virtual可有可无）
  + 注意：函数重载不能与默认参数同时使用，会有二义性
+ 本质：C++编译器对同名函数的重命名
+ 函数重载是静态多态（编译时的多态）

```C++
class A{
    ...
    virtual int fun();
    void fun(int);
    void fun(double, double);
    static int fun(char);
    ...
}


```

## （2）隐藏（hide）函数重定义

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数（派生类无法直接找到基类同名函数）。

+ 作用域：继承体系中
+ 规则：
  + 同名同参，基类要是非虚函数
  + 同名不同参，不管基类是否为虚函数。

- 两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**

+ 隐藏和重载的区别：
  + 关键在于作用域不一样。
  + 同名同参不能重载。

+ 将隐藏变为重载：**用using关键字，将函数隐藏变为函数重载**：自定义命名空间一节提到using可将一个作用域中的名字引入另一个作用域中

## （3）重写（覆盖）（override）

**背景**：在面向对象的继承关系中，父类提供方法无法满足子类需求，需要重新定义父类方法。

**目的**：实现多态调用；

**规则：**

+ 不同范围（派生类和基类）
+ 函数名相同
+ 参数相同
+ 基类有virtual关键字，**派生类可有可无**。不能有static

**函数重写本质**：**虚函数表内函数地址的重写**

```C++
//父类
class A{
public:
    virtual int fun(int a){}
}
//子类
class B : public A{
public:
    //重写,一般加override可以确保是重写父类的函数
    virtual int fun(int a) override{}
}


```

重载与重写的区别：

- 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
- 重载实现静态多态，重写实现动态多态。

# 36、C++的多态如何实现

**多态含义：**同一种事物的不同形态。（调用同一种函数可以完成不同功能）

**多态分类：**

+ 静态多态（编译时的多态）：函数和运算符的重载。
+ 动态多态（运行时的多态）：和继承和虚函数有关。

**背景：**

+ 对象和函数的关联
  + 静态关联：将对象和函数绑定，使用对象名（对象名只有静态关联）调用函数 
  + 动态关联：将对象和函数绑定，使用指针或引用（他两既有静态也有动态）调用虚函数
+ 现实情况：在继承中，通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数.

**解决：继承+虚函数**

+ 虚函数重写：在基类的函数前加上**virtual**关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数、
+ 父类指针或者引用指向子类对象。

**多态底层实现：**

+ 虚函数：编译阶段，为虚函数建立虚函数表。

  > 普通函数和虚函数的区别：
  >
  > + 虚函数时动态绑定，绑定到虚函数表中
  > + 普通函数静态绑定，直接绑定到类中

+ 虚表（绑定到类，对象共享）：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译阶段，编译器会自动生成虚表

  > 虚表本质**：一个在编译时就已经确定好了的**`void*` 类型的指针数组 。**编译期间, 就会为这个类分配一片连续的内存 (这就是虚表vftable), 来存放虚函数的地址**

+ 虚表指针（绑定到对象）：在含有虚函数的类实例化对象时，使用虚表指针记录虚表地址

  > 对象实例化时，（**初始化，存储在对象地址的前四个字节**）

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/微信截图_20210201114227.png)

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/微信截图_20210201114257.png)

**上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：**

**（1）虚表生成**编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。

+ **单继承未重写虚函数**

  父类虚表拷贝一份，将新的虚表地址赋予派生类作为虚函数指针

  如果派生类中新增了虚函数, 则会加继承的虚表后面

+ **单继承重写虚函数**: 函数重写本质：虚函数表内函数地址的重写

  继承的虚表中被重写的虚函数地址会在继承虚表时被修改为派生类函数的地址
  (注意: 此时基类的虚表并没有被修改, 修改的是派生类自己的虚表)

**（2）虚表指针构造时初始化**编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数

最终：指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

> 《C++实现多态的原理》：https://blog.csdn.net/qq_37954088/article/details/79947898

```C++
#include <iostream>
using namespace std;

class Base{
public:
	virtual void fun(){
		cout << " Base::func()" <<endl;
	}
};

class Son1 : public Base{
public:
	virtual void fun() override{
		cout << " Son1::func()" <<endl;
	}
};

class Son2 : public Base{

};

int main()
{
	Base* base = new Son1;
	base->fun();
	base = new Son2;
	base->fun();
	delete base;
	base = NULL;
	return 0;
}
// 运行结果
// Son1::func()
// Base::func()


```

例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？这里需要引出虚表和虚基表指针的概念。

# 37、C++有哪几种的构造函数

C++中的构造函数可以分为4类：

- 默认构造函数 ：

- 初始化构造函数（有参数）

- 拷贝构造函数

- 移动构造函数（move和右值引用）

- 委托构造函数

- 转换构造函数

  > 转换构造函数用于将其他类型的变量，隐式转换为本类对象
  >
  > 特点：形参是其他类型变量，且只有一个形参

举个例子：

```C++
#include <iostream>
using namespace std;

class Student{
public:
    Student(){//默认构造函数，没有参数
        this->age = 20;
        this->num = 1000;
    };  
    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
        this->age = s.age;
        this->num = s.num;
    }; 
    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = r;
		this->num = 1002;
    };
    ~Student(){}
public:
    int age;
    int num;
};

int main(){
    Student s1;
    Student s2(18,1001);
    int a = 10;
    Student s3(a);
    Student s4(s3);
    
    printf("s1 age:%d, num:%d\n", s1.age, s1.num);
    printf("s2 age:%d, num:%d\n", s2.age, s2.num);
    printf("s3 age:%d, num:%d\n", s3.age, s3.num);
    printf("s2 age:%d, num:%d\n", s4.age, s4.num);
    return 0;
}
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002


```

> 《浅谈C++中的几种构造函数》：https://blog.csdn.net/zxc024000/article/details/51153743

# 38、浅拷贝和深拷贝的区别

用途：类成员变量中有指针

**浅拷贝**

+ 定义：浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，
+ 如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

**深拷贝**

+ 定义：深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，
+ 释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝构造函数的时候，如果有指针变量的话是需要自己实现深拷贝的。

```C++
#include <iostream>  
#include <string.h>
using namespace std;
 
class Student
{
private:
	int num;
	char *name;
public:
	Student(){
        name = new char(20);
		cout << "Student" << endl;
    };
	~Student(){
        cout << "~Student " << &name << endl;
        delete name;
        name = NULL;
    };
	Student(const Student &s){//拷贝构造函数
        //浅拷贝，当对象的name和传入对象的name指向相同的地址
        name = s.name;
        //深拷贝
        //name = new char(20);
        //memcpy(name, s.name, strlen(s.name));
        cout << "copy Student" << endl;
    };
};
 
int main()
{
	{// 花括号让s1和s2变成局部对象，方便测试
		Student s1;
		Student s2(s1);// 复制对象
	}
	system("pause");
	return 0;
}
//浅拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffed0c3ec0
//~Student 0x7fffed0c3ed0
//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***

//深拷贝执行结果：
//Student
//copy Student
//~Student 0x7fffebca9fb0
//~Student 0x7fffebca9fc0


```

从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。

> 《C++面试题之浅拷贝和深拷贝的区别》：https://blog.csdn.net/caoshangpa/article/details/79226270

# 39、内联函数和宏定义的区别

**内联(inline)函数和普通函数区别：**

+ 内联函数代码是被放到**符号表**中，使用时**像宏一样展开**，没有调用的开销，效率很高；

  相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。

**内联函数适用场景**

- 使用宏定义的地方都可以使用inline函数
- 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率

**为什么不能把所有的函数写成内联函数**

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：

- 函数体内的代码比较长，将导致内存消耗代价
- 函数体内有循环，函数执行时间要比函数调用开销大

**主要区别**

- **时期：**内联函数在编译时展开，宏在预编译时展开
- **方法：**内联函数直接嵌入到目标代码中，宏是简单的做文本替换
- **类型检测：**宏只做简单字符串替换（编译前）而内联函数可以进行参数类型检查（编译时），且具有返回值。
- **函数vs定义：**内联函数是函数，有函数功能，宏不是
- 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义

> 《inline函数和宏定义区别 整理》：https://blog.csdn.net/wangliang888888/article/details/77990650

- **封装（局部vs全局）**内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

# 40、构造函数、析构函数、虚函数可否声明为内联函数

+ **总体答案：**声明这些内联函数，，在语法上没有错误。因为inline同register一样，只是个建议，最终决定权还是在编译器手上。

> register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率 

+ **构造函数和析构函数声明为内联函数是没有意义的**

  + 《Effective C++》中所阐述的是即编译器并不真正对声明为inline的构造和析构函数进行内联操作，**因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等）**，致使构造函数/析构函数并不像看上去的那么精简。

  + 类中函数默认inline，此时声明inline没有意义

+ **将虚函数声明为inline，要分情况讨论**
  + （动态绑定）当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；
  + （静态绑定）当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

举个例子：

```C++
#include <iostream>
using namespace std;
class A
{
public:
    inline A() {
		cout << "inline construct()" <<endl;
	}
    inline ~A() {
		cout << "inline destruct()" <<endl;
	}
    inline virtual void  virtualFun() {
		cout << "inline virtual function" <<endl;
	}
};
 
int main()
{
	A a;
	a.virtualFun();
    return 0;
}
//输出结果
//inline construct()
//inline virtual function
//inline destruct()


```

> 《构造函数、析构函数、虚函数可否内联，有何意义》：https://www.cnblogs.com/helloweworld/archive/2013/06/14/3136705.html

# 41、auto、decltype和decltype(auto)的用法

+ auto（自动类型推演）：应用：把表达式的值付给变量,需要在声明变量的时候清楚的知道变量是什么类型
  + auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。
+ decltype（类型获取）：应用：希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量
  + **选择并返回操作数的数据类型**。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值
+ decltype(auto)：在使用时，会将“=”号右边的表达式替换掉auto，再根据decltype的语法规则来确定类型

**（1）auto**

+ **auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。**举个例子：

```c++
//普通；类型
int a = 1, b = 3;
auto c = a + b;// c为int型

//const类型
const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
auto k = &i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt

//引用和指针类型
int x = 2;
int& y = x;
auto z = y; //z是int型不是int& 型
auto& p1 = y; //p1是int&型
auto p2 = &x; //p2是指针类型int*


```

**（2）decltype**

有的时候我们还会遇到这种情况，**我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。**还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，**它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。**

```C++
int func() {return 0};

//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()
int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留   
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const
int e = 4;
const int* f = &e; // f是底层const
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用
const int i = 3, &j = i;
decltype(j) k = 5; // k的类型是 const int&

//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型

//3. 对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起

//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起


```

**（3）decltype(auto)**

decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：

```C++
int e = 4;
const int* f = &e; // f是底层const
decltype(auto) j = f;//j的类型是const int* 并且指向的是e
```

> 《auto和decltype的用法总结》：https://www.cnblogs.com/XiangfeiAi/p/4451904.html
>
> 《C++11新特性中auto 和 decltype 区别和联系》：https://www.jb51.net/article/103666.htm

# 42、public，protected和private访问和继承权限/public/protected/private的区别？

- public的变量和函数在类的内部外部都可以访问。

- protected的变量和函数只能在类的内部和其派生类中访问。

- private修饰的元素只能在类内访问。

| 类别              | -public继承 | protected继承 | private继承 |
| :---------------- | ----------- | ------------- | ----------- |
| public公共权限    | public      | protected     | private     |
| protected保护权限 | protected   | protected     | private     |
| private私有权限   | private     | private       | private     |

public：基类的访问权限不变

protected：除了private，其他权限变为protected

private：所有权限变为private。

1. 继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。

2. **private不可访问的原因：private成员变量被继承但不可见**

   基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，**基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见**，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。

3. 子类非要访问父类私有变量

   在派生类中访问基类 private 成员的唯一方法就是借助基类的**非 private 成员函数**，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问

4. 由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。

# 43、如何用代码判断大小端存储

**大端和小端：**

+ 大端存储：数据的高字节存储在低地址中（从大到小）

+ 小端存储：字数据的低字节存储在低地址中（从小到大）

**判断方案：**

+ 使用强制类型转换：int转为char 由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分

例如：32bit的数字0x12345678

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134200013.png)

大端模式中的存储方式为：

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564134220855.png)

了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：

**方式一：使用强制类型转换**-这种法子不错

```C++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}


```

方式二：巧用union联合体

```C++
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}


```

> 《写程序判断系统是大端序还是小端序》：https://www.cnblogs.com/zhoudayang/p/5985563.html

# 44、volatile、mutable和explicit关键字的用法

## (1)**volatile**

+ volatile 关键字是一种类型修饰符，**用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，**编译器对访问该变量的代码就不再进行优化**，从而可以提供对特殊地址的稳定访问。

+  当使用 volatile 声明的变量的值的时候，**系统总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。

**volatile 指针**：volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念

+ volatile指针：指向对象是const或者volatile

  ```C++
  const char* cpch;
  volatile char* vpch;
  ```

+ 指针volatile：指针本身是volatile

  ```C++
  char* const pchc;
  char* volatile pchv
  ```

**注意：**

- 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。
- 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。

**多线程下的volatile**   

>  有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。**如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

## （2）**mutable**

定义：mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词

作用：**突破const权限**，在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。

+ 类中计数功能。计数变量声明为mutable

  ```C++
  class Person {
  public:
      Person();
      ~Person();
  
      int getAge() const; /*调用方法*/
      int getCallingTimes() const; /*获取上面的getAge()方法被调用了多少次*/
  private:
      int age;
      char *name;
      float score;
      mutable int m_nums;            /*用于统计次数*/
  };
  nt Person::getAge() const
  {
      std::cout << "Calling the method" << std::endl;
      m_nums++;
      // age = 4; 仍然无法修改该成员变量
      return age;
  }
  ```

## （3）**explicit**

explicit关键字用来修饰类的构造函数，只能以**显示的方式进行类型转换**，不能使用隐式转换。注意以下几点：

- explicit 关键字只能用于**类内部的构造函数声明**

- explicit 关键字作用于**单个参数的构造函数**

- 被explicit修饰的构造函数的类，不能发生相应的**隐式类型转换**

# 45、什么情况下会调用拷贝构造函数

- **直接初始化和赋值**：用类的一个实例化对象去初始化另一个对象的时候
- **参数时为非引用对象**：函数的参数是类的对象时（非引用传递）
- **函数返回局部对象**：此时虽然会发生NRV优化，但是返回值传递，仍然会调用拷贝构造函数
  + linux环境下，返回值传递还是引用传递，都不会调用拷贝构造函数
  + window下，**值返回会调用拷贝构造函数**，**引用传递不会调用拷贝构造函数**。

## NRV优化；

NRV优化：A a=f().函数需要返回一个A对象，

+ 传统方法：在函数中建立一个局部对象x1，将a用引用方式传递到函数中，调用拷贝构造函数，将x1赋值给a。
+ NRV优化：将a引用方式传入函数中，直接替代局部对象x1，将原来**拷贝构造变为默认构造。**

# 46、C++中有几种类型的new

在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new

1. plain new (简单new)：普通new,内存分配失败，抛出bad_allot异常

2. nothrow new(不抛出异常new)，内存分配失败，返回null，不抛出异常

3. placement new(布置new)，在一块已经分配内存上，重新构造对象或者对象数组，不需要分配内存，调用构造函数即可

   + 主要用途：反复调用一块较大的动态内存从而构造对象或者数组
   + 针对对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或**数组大小并不一定等于原来分配的内存大小**，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。


## （1）**plain new**

言下之意就是普通的new，就是我们常用的new，在C++中定义如下：

```C++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：

```C++
#include <iostream>
#include <string>
using namespace std;
int main()
{
	try
	{
		char *p = new char[10e11];
		delete p;
	}
	catch (const std::bad_alloc &ex)
	{
		cout << ex.what() << endl;
	}
	return 0;
}
//执行结果：bad allocation
```

## （2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：

```C++
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

举个例子：

```C++
#include <iostream>
#include <string>
using namespace std;

int main()
{
	char *p = new(nothrow) char[10e11];
	if (p == NULL) 
	{
		cout << "alloc failed" << endl;
	}
	delete p;
	return 0;
}
//运行结果：alloc failed
```

## （3）**placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：

```C++
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

使用placement new需要注意两点：

- palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组

- placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

举个例子：

```C++
#include <iostream>
#include <string>
using namespace std;
class ADT{
	int i;
	int j;
public:
	ADT(){
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << "j="<<j <<endl;
	}
	~ADT(){
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char *p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
	}
	ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct
```

> 《【C++】几种类型的new介绍》：https://www.jianshu.com/p/9b57e769c3cb

# 47、C++中NULL和nullptr区别

## 总结：

**背景：**兼容C语言

+ NULL来自C语言，一般由宏定义实现，NULL被定义为**(void*)0**
+ C++语言中，NULL则被定义为**整数0**

**问题：**C++的NULL无法和整数0进行区分。使用NULL进行函数重载会发生二义性`f(char * c)和f(int c)`产生二义性。

**解决：**nullptr在C++11被引入用于解决这一问题，**nullptr是明确的空指针，属于指针类型**，可以明确区分**整型和指针类型**，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。

**缺陷：**不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的**指明参数类型。**



## 详细

算是为了与C语言进行兼容而定义的一个问题吧

NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。**在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0**。编译器一般对其实际定义如下：

```C++
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif

```


在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：

```C++
#include <iostream>
using namespace std;

void fun(char* p) {
	cout << "char*" << endl;
}

void fun(int p) {
	cout << "int" << endl;
}

int main()
{
	fun(NULL);
	return 0;
}
//输出结果：int



```

那么**在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。**

nullptr的一种实现方式如下：

```C++
const class nullptr_t{
public:
    template<class T>  inline operator T*() const{ return 0; }
    template<class C, class T> inline operator T C::*() const { return 0; }
private:
    void operator&() const;
} nullptr = {};



```


以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，**另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。**但nullptr仍然存在一定问题，例如：

```C++
#include <iostream>
using namespace std;

void fun(char* p)
{
	cout<< "char* p" <<endl;
}
void fun(int* p)
{
	cout<< "int* p" <<endl;
}

void fun(int p)
{
	cout<< "int p" <<endl;
}
int main()
{
    fun((char*)nullptr);//语句1
	fun(nullptr);//语句2
    fun(NULL);//语句3
    return 0;
}
//运行结果：
//语句1：char* p
//语句2:报错，有多个匹配
//3：int p


```

在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。

> 《NULL和nullptr区别》：https://blog.csdn.net/qq_39380590/article/details/82563571

# 48、简要说明C++的内存分区

C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。如下图所示

+ **栈**：函数执行时，函数内部局部变量在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限

+ **堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

+ **自由存储区**：就是那些由`malloc`等分配的内存块，它和堆是十分相似的，不过它是用`free`来结束自己的生命的

+ **全局/静态存储区**：
  + **全局变量和静态变量：**全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区。
  + **自动初始化：**在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

+ **常量存储区**：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改

+ **代码区**：存放函数体的二进制代码

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1564479734552.png)

　

> 《C/C++内存管理详解》：https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/

# 49、C++的异常处理的方法

## 总结：

**常见异常**：

- 数组下标越界
- 除法计算时除数为0
- 动态分配空间时空间不足

**解决思路**：C++中的异常处理机制主要使用**try**、**throw**和**catch**三个关键字。

+ **try**、**throw**和**catch**使用

  + 程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，

  + throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

+ **函数的异常声明列表**

  程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表

  `int fun() throw(int,double,A,B,C){...};`

+ **C++标准异常类  exception**

  C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来

  + bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常
  + bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
  + bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
  + out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常

## 详细：

在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：

- 数组下标越界
- 除法计算时除数为0
- 动态分配空间时空间不足
- ...

如果不及时对这些异常进行处理，程序多数情况下都会崩溃。

**（1）try、throw和catch关键字**

C++中的异常处理机制主要使用**try**、**throw**和**catch**三个关键字，其在程序中的用法如下：

```C++
#include <iostream>
using namespace std;
int main()
{
    double m = 1, n = 0;
    try {
        cout << "before dividing." << endl;
        if (n == 0)
            throw - 1;  //抛出int型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch (double d) {
        cout << "catch (double)" << d << endl;
    }
    catch (...) {
        cout << "catch (...)" << endl;
    }
    cout << "finished" << endl;
    return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished


```

代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。

**（2）函数的异常声明列表**

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：

```C++
int fun() throw(int,double,A,B,C){...};


```

这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常

**（3）C++标准异常类  exception**

C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示

![](https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.2/202102/1-1P912101914246.jpg)

- bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：

```C++
#include <iostream>
#include <typeinfo>
using namespace std;

class A{
public:
  virtual ~A();
};
 
using namespace std;
int main() {
	A* a = NULL;
	try {
  		cout << typeid(*a).name() << endl; // Error condition
  	}
	catch (bad_typeid){
  		cout << "Object is NULL" << endl;
  	}
    return 0;
}
//运行结果：bject is NULL



```

- bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
- bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
- out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常

> 《C++异常处理（try catch throw）完全攻略》：http://c.biancheng.net/view/422.html

# 50、static的用法和作用？

## 类外static

+ **隐藏（作用范围）**（最重要作用）：所有未加static前缀的全局变量和函数都具有全局可见性。

+ **持久（生命周期）**（static变量中的记忆功能和全局生存期）：程序运行前，全局区（全局变量和静态变量）的变量已经分配内存，并进行初始化（唯一一次初始化）。
+ **默认初始化**：static的第三个作用是默认初始化为0（static变量）

## 类内static

+ **static变量类共享（与普通变量的区别）**：该变量内存分配初始化一次，被所有对象共享，只存在一份拷贝。

+ **类外初始化：**static类对象必须要在类外进行初始化（声明加static，定义不需要加static），static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；**初始化只有一次，赋值可以有多次**。

+ **访问方式：**可以对象访问，也可以类名访问。

+ **static函数没有this指针**（与普通函数的区别）：在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

+ **static函数不能virtual修饰**：

  + tatic成员不属于任何对象或实例，所以加上virtual没有任何实际意义
  + 静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

  

## 全局变量。静态变量、初始化时间

+ 全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；

+ 局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化

# 52、const关键字?

## 函数内const：

+ **const 变量 阻止改变**：定义该const变量时，通常需要对它进行初始化（**定义初始化**），因为以后就没有机会再去改变它了；  
+ 指针常量和常量指针。
+ **const 形参** ：表明它是一个输入参数，在函数内部不能改变其值；
  + 普通类型，加不加const对实参没有影响，影响的是形参变量
  + 指针引用类型，可以通过const重载，编译阶段可以通过是否保护实参来进行区分。
+ const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；

## 类内const：

+ **const 成员变量**：类内直接初始化（定义初始化），或者提供初始化列表初始化
+ **const 成员函数（常函数）**：不能修改类的成员变量，可以访问**常对象所有成员**和 **非常对象的所有成员**；  
+ **普通 成员函数：**不能修改类的成员变量，可以访问所有非const对象，**不能访问const对象**。

+ **返回值const**：有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

+ const对象只能调用const函数，使用const成员变量： 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。

# 54、形参与实参的区别？

1)  **生命周期**：形参变量的生命周期仅仅在函数内部。函数结束释放。

2)  **临时变量**：实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，通过实参产生临时变量，然后赋值给形参。

3)  **类型不匹配**：实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

4) **数据传送单向**：形参变化不影响实参，形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量



# 55、值传递、指针传递、引用传递的区别和效率

1)   **值传递**：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）

2)  **指针传递**：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）

3)  **引用传递**：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）

4)  效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。



# 56、什么是类的继承？

1) 类与类之间的关系

+ has-A（包含关系，成员对象）用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；

+ use-A，（依赖关系，传递参数，友元）一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；

+ is-A，继承关系，关系具有传递性；

2) 继承的相关概念

+ **继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法**，被称为子类或者派生类，被继承的类称为父类或者基类；

3) 继承的特点

+ 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；

4) 继承中的访问控制

+ public、protected、private

5) 继承中的构造和析构函数：构造函数和析构函数无法继承。



# 57、什么是内存池，如何实现

>https://www.bilibili.com/video/BV1Kb411B7N8?p=25 C++内存管理：P23-26
>
>https://www.bilibili.com/video/BV1db411q7B8?p=12 C++STL P11

内存池（Memory Pool） 是一种**内存分配**方式。

+ 通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。
+ 内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

## 内存池实现机制

**allocator：用于分配内存**

+ allocate()申请内存
+ deallocate()回收内存
+ 内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，

**实现流程**

一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小

1. 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）
2. 客户端之后有有内存需求，想申请（20\*64bytes）的空间，这时内存池只有（20*32bytes），就先将（10\*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也
3. 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。
4. 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常

> 《STL源码解析》侯捷 P68

allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来和，外部（一般指容器）调用的时候只需要知道这些就够了。说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。 

## new 和operator new 的区别

+ new 是个运算符，编辑器会调用 operator new(0)

+ operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作

# 58、从汇编层去解释一下引用

~~~cpp
9:      int x = 1;

00401048  mov     dword ptr [ebp-4],1

10:     int &b = x;

0040104F   lea     eax,[ebp-4]

00401052  mov     dword ptr [ebp-8],eax


~~~

引用本质：将变量地址存入变量b中。

+ 将变量地址放入寄存器
+ 降后将寄存器内容，赋值给一个指针

x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。

+ lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器

+ mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址

ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。

# 59、深拷贝与浅拷贝是怎么回事？

+ 浅拷贝：直接将数据进行简单复制：
  + 对于基本数据类型，复制值
  + 对于引用和指针数据类型，复制地址，指向相同对象

+ 深拷贝：在计算机中重新开辟一个内存，对对象进行整体拷贝

浅拷贝问题：

+ 对于类中指针，进行对象赋值时，两个对象的指针指向同一个内存，这就出现了问题（析构内存的多次释放，或者访问不存在内存）：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

# (?)60、C++模板是什么，你知道底层怎么实现的？

1) **编译器两次编译（声明和调用）**：编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。

2)  **函数模板的实例化**：这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。



# 61、new和malloc的区别？

1、 **关键字VS库函数：**new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；

2、 **内存大小分配**：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

3、 **返回指针**：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

4、 **分配失败：**new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

5、 **自定义类型构造和析构**：

+ （**先分配内存malloc，然后调用构造函数**）：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。
+ （**先析构，然后释放分配内存**free）delete先调用析构函数，然后调用**operator delete**函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

# （？）62、new、new[] 、delete p、delete [] p、allocator都有什么作用？

1、 new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；

2、 **new返回指针类型**：new动态数组返回的并不是数组类型，而是一个元素类型的指针；

3、 **delete[] 元素逆序销毁**：delete[]时，数组中的元素按逆序的顺序进行销毁；

4、 new,delete 和allocateor的区别

+ new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。

+ **allocator：stl中的内存分配器，将内存分配的初始化工作分离；**将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

# （？）63、new和delete的实现原理， delete是如何知道释放内存的大小的额？

new对于不同的数据类型操作：

+ 简单类型：直接直接调用operator new分配内存，
+ 复杂类型：调用operator new分配内存，然后调用构造函数
+ new[]分配数组
  + 简单类型：先计算大小，然后调用operator new；
  + 复杂类型：new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；

new具体步骤：

①  new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；

②   编译器运行相应的构造函数以构造这些对象，并为其传入初始值；

③   对象被分配了空间并构造完成，返回一个指向该对象的指针。

delete对不同数据类型操作

+ 简单类型：delete简单数据类型默认只是调用free函数
+ 复杂类型：复杂数据类型先调用析构函数再调用operator delete
+ delete[]删除数组；
  + 简单类型，delete和letete[]相同（？delete记录大小）
  + 复杂类型：假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

C++记录复杂类型数组的大小。

需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。



# 64、malloc申请的存储空间能用delete释放吗

## new和申请空间free释放

不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。

+ malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。但delete会自动进行类型检查的大小计算

+ malloc/free不能执行构造函数与析构函数，无法释放动态对象它是不行的。

## malloc申请存储空间使用delete释放

+ 从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。



# 65、malloc与free的实现原理？

new中的通过封装malloc实现内存分配：

+ malloc堆内存分配，和free内存释放

  malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。**操作系统中有一个记录空闲内存地址的链表**。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;

2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；

3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。

# 66、malloc、realloc、calloc的区别

+ malloc函数：普通分配，手动计算空间，值随机初始化

~~~cpp
void* malloc(unsigned int num_size);

int *p = malloc(20*sizeof(int));申请20个int类型的空间；
~~~

+ calloc函数：分配，不需要计算空间，值默认初始化为0

~~~cpp
void* calloc(size_t n,size_t size);

int *p = calloc(20, sizeof(int));
~~~

省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；

3)   realloc函数：给动态分配的空间分配额外的空间，用于扩充容量。

~~~cpp
void realloc(void *p, size_t new_size);
~~~

# 67、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？

## 类成员初始化方式

+ 赋值初始化，通过在函数体内进行赋值初始化，（**先分配空间，然后赋值**）在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。

+ 列表初始化，在冒号后使用初始化列表进行初始化。列表初始化是给数据成员分配内存空间时就进行初始化，即在进入函数体前已经对成员变量完成初始化操作。

  

## 一个派生类构造函数的执行顺序如下：

①   虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。

②   基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。

③   类类型的成员对象的构造函数（按照初始化顺序）

④   派生类自己的构造函数。

## **列表初始化快原因**：

+ **临时对象产生**：方法一是在构造函数当中做赋值的操作，方法二是做纯粹的初始化操作。我们都知道，**C++的赋值操作是会产生临时对象的**。临时对象的出现会降低程序的效率。

+ 多调用一次默认构造函数

  > 内置数据类型，复合类型（指针，引用）。没有差别。
  > 用户定义类型（类类型）。差别很大
  >
  > 对于用户定义类型：
  > 1）如果使用类初始化列表，直接调用对应的构造函数即完成初始化
  > 2）如果在构造函数中初始化，那么首先调用默认的构造函数，然后调用指定的构造函数
  >
  > 所以对于用户定义类型，使用列表初始化可以减少一次默认构造函数调用过程
  >
  > 
  >
  > 构造函数运行顺序;
  >
  > + 初始化列表：对内置对象进行构造
  > + 运行函数体：对于赋值操作，调用个拷贝赋值操作符=才能完成

用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。举个例子：

```C++
#include <iostream>
using namespace std;
class A
{
public:
    A()
    {
        cout << "默认构造函数A()" << endl;
    }
    A(int a)
    {
        value = a;
        cout << "A(int "<<value<<")" << endl;
    }
    A(const A& a)
    {
        value = a.value;
        cout << "拷贝构造函数A(A& a):  "<<value << endl;
    }
    int value;
};

class B
{
public:
    B() : a(1)
    {
        b = A(2);
    }
    A a;
    A b;
};
int main()
{
    B b;
}

//输出结果：
//A(int 1)
//默认构造函数A()
//A(int 2)
```

从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但**如果有些成员是类**，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。**

> 《为什么用成员初始化列表会快一些？》：https://blog.csdn.net/JackZhang_123/article/details/82590368

# 68、成员列表初始化？

1)  必须使用成员初始化的四种情况

①    当初始化一个引用成员时；

②    当初始化一个常量成员时；

③    当调用一个基类的构造函数，而它拥有一组参数时；

④    当调用一个成员类的构造函数，而它拥有一组参数时；

2)  成员初始化列表做了什么

①    **编译器会一一操作初始化列表**，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；

②    list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

# 69、什么是内存泄露，如何检测与避免

**内存泄露**：无法释放已经申请的内存。一般我们常说的内存泄漏是指**堆内存的泄漏**。

+ 栈上分配指针指向堆内分配的内存，函数调用结束，栈中的内存被释放，然后无法释放堆中的内存，此时发生内存泄露。

**内存溢出：**内存溢出是指存储的数据超出了指定空间的大小，这时数据就会越界，

+ 举例来说，常见的溢出，是指在栈空间里，分配了超过数组长度的数据，导致多出来的数据覆盖了栈空间其他位置的数据，这

**避免内存泄露的几种方式**

- 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
- 一定要将**基类的析构函数**声明为**虚函数**
- 对象数组的释放一定要用**delete []**
- 有new就有delete，有malloc就有free，保证它们一定成对出现

**检测工具**

- Linux下可以使用**Valgrind工具**
- Windows下可以使用**CRT库**

# 70、对象复用的了解，零拷贝的了解

**对象复用**

+ 对象复用其本质是一种设计模式：Flyweight享元模式。

+ 通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。

**零拷贝**

+ 零拷贝就是一种**避免 CPU 将数据从一块存储拷贝到另外一块存储的技术**。

+ 零拷贝技术可以减少数据拷贝和共享总线操作的次数。

例子：vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部

+ **emplace_back()**：使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高
+ **push_back()**：使用push_back()函数需要调用拷贝构造函数和转移构造函数

```C++
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct Person
{
    string name;
    int age;
    //初始构造函数
    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)
    {
         cout << "I have been constructed" <<endl;
    }
     //拷贝构造函数
     Person(const Person& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been copy constructed" <<endl;
    }
     //转移构造函数
     Person(Person&& other): name(std::move(other.name)), age(other.age)
    {
         cout << "I have been moved"<<endl;
    }
};

int main()
{
    vector<Person> e;
    cout << "emplace_back:" <<endl;
    e.emplace_back("Jane", 23); //不用构造类对象

    vector<Person> p;
    cout << "push_back:"<<endl;
    p.push_back(Person("Mike",36));
    return 0;
}
//输出结果：
//emplace_back:
//I have been constructed
//push_back:
//I have been constructed
//I am being moved.
```

# 71、解释一下什么是trivial destructor

+ “trivial destructor”：默认析构函数 一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。
+ non-trivial destructor：自定义的析构函数，种析构函数**如果申请了新的空间一定要显式的释放，否则会造成内存泄露**

C++判断是否需要调用trival destructor

+ 首先利用value_type()获取所指对象的型别，再利用\__type_traits<T>判断该型别的析构函数是否trivial，若是(\_\_true_type)，则什么也不做，若为(\_\_false_type)，则去调用destory()函数

也就是说，在实际的应用当中，STL库提供了相关的判断方法**__type_traits**，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。

> 《C++中的 trivial destructor》：https://blog.csdn.net/wudishine/article/details/12307611

# 72、介绍面向对象的三大特性，并且举例说明

三大特性：继承、封装和多态

**（1）继承：**

+ 定义：**让某种类型对象获得另一个类型对象的属性和方法**。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

常见的继承有三种方式：

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力
2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）

例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法

**（2）封装**

+ 定义：**将数据和代码捆绑在一起，对外界隐藏实现细节，**避免外界干扰和不确定性访问。
+ 封装：将客观事物封装成类，将事物的数据和方法绑定到一起。
+ 隐藏：为事物的数据和成员设定权限，暴露接口，隐藏细节实现。

**（3）多态**  

+ 定义：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为

多态分类：

+ 静态多态：函数重载（条件）
+ 运行多态：虚函数重写（条件）

举例子：例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

# 73、C++中类的数据成员和成员函数内存分布情况

C++类和结构体的成员内存分布情况一样

+ 空类：占用一个字节长度。空类中没有非静态(non-static)数据成员变量，没有虚函数(virtual function)，也没有虚基类(virtual base class)。
+ 类内存：非静态成员变量，虚表指针，虚基类指针。
  + 首地址：一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。或者虚函数指针
+ 成员函数：不占用对象内存，
  + 静态成员函数的普通成员函数均存放在代码区，区别是静态成员函数没有this指针。

（在定义类对象的同时这些成员变量也就被定义了），举个例子：

```C++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        this->age = 23;
    }
    void printAge()
    {
        cout << this->age <<endl;
    }
    ~Person(){}
public:
    int age;
};

int main()
{
    Person p;
    cout << "对象地址："<< &p <<endl;
    cout << "age地址："<< &(p.age) <<endl;
    cout << "对象大小："<< sizeof(p) <<endl;
    cout << "age大小："<< sizeof(p.age) <<endl;
    return 0;
}
//输出结果
//对象地址：0x7fffec0f15a8
//age地址：0x7fffec0f15a8
//对象大小：4
//age大小：4



```

从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。 我们再来补充一下静态成员函数的存放问题：**静态成员函数与一般成员函数的唯一区别就是没有this指针**，因此不能访问非静态数据成员，就像我前面提到的，**所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。**

> 《C++类对象成员变量和函数内存分配的问题》：https://blog.csdn.net/z2664836046/article/details/78967313

# 构造函数和析构函数

## 75、(超重要)构造函数为什么不能为虚函数？析构函数为什么要虚函数？

构造函数：

+ **实现角度：**初始化前没有虚函数指针，虚函数需要使用虚函数表指针来调用，虚函数表指针存放在类内部，类没有初始化，没有虚函数指针。

+ **使用角度**：虚函数作用：父类指针或引用指向子类对象，调用子类对象的成员函数。构造函数属于对象自己调用，无需要父类调用，没必要虚函数，而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数

析构函数：C++中基类采用virtual虚析构函数是**为了防止内存泄漏。**

+ 内存泄露：具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，**当删除基类指针指向的派生类对象时就不会触发动态绑定**，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

  所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

## **构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。**

那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。

VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。





## 76、构造函数和析构函数的作用？ 

1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。

规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。 

2)  析构函数与构造函数的作用相反，**用于撤销对象的一些特殊任务处理**，可以**是释放对象分配的内存空间**；特点：析构函数与构造函数同名，但该函数前面加~。 

析构函数的特点：

+ 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

+ 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。 



## 77、构造函数和析构函数可以调用虚函数吗，为什么

简要结论：

-  从语法上讲，调用完全没有问题。
-  但是从效果上看，往往不能达到需要的目的。 

解释：

+ 构造函数

  + **不进行动态链接**：构造函数和析构函数调用虚函数不是用动态链接，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；

  + **构造顺序**：因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；

+ 析构函数

  + 析构顺序：先子类后父类，所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。

  

  -  

  > 《Effective C++》的解释是： 
  > 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。

  举个例子：

  ```C++
  #include<iostream>
  using namespace std;
  
  class Base
  {
  public:
      Base()
      {
         Function();
      }
  
      virtual void Function()
      {
          cout << "Base::Fuction" << endl;
      }
  	~Base()
  	{
  		Function();
  	}
  };
  
  class A : public Base
  {
  public:
      A()
      {
        Function();
      }
  
      virtual void Function()
      {
          cout << "A::Function" << endl;
      }
  	~A()
  	{
  		Function();
  	}
  };
  
  int main()
  {
      Base* a = new Base;
  	delete a;
  	cout << "-------------------------" <<endl;
  	Base* b = new A;//语句1
  	delete b;
  }
  //输出结果
  //Base::Fuction
  //Base::Fuction
  //-------------------------
  //Base::Fuction
  //A::Function
  //Base::Fuction
  
  
  
  ```

  语句1讲道理应该体现多态性，执行类A中的构造和析构函数，从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数，析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免

  > 《构造函数或者析构函数中调用虚函数会怎么样？》：https://dwz.cn/TaJTJONX

  

## 78、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？

**1)     构造函数顺序**

①   基类构造函数。多个基类（声明顺序构造，而不是初始化列表顺序）

②   成员类对象构造函数。多个成员对象（）声明顺序构造，而不是初始化列表顺序

③   派生类构造函数。

**2)     析构函数顺序**（和构造函数相反）

①   调用派生类的析构函数；

②   调用成员类对象的析构函数；

③   调用基类的析构函数。



## 79、虚析构函数的作用，父类的析构函数是否要设置为虚函数？

+ 虚析构函数为了防止内存泄露
  
+ 假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
  
+ 纯析构函数，子类一定得实现。

  +纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。 因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，**最好不要把虚析构函数定义为纯虚析构函数。**



## 80、（？）构造函数、析构函数可否抛出异常

1)   C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。

因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。

2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；

3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；

4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。



## 82、对象的析构时机？

1)  **对象生命周期结束**：对象生命周期结束，被销毁时；

2)  **使用delete**，delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；

3)  **成员对象：**一个对象是另一个对象成员对象。



## 85、构造函数的几种关键字

+ default:显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错

  `CString() = default;`

+ delete:删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示

  `void* operator new() = delete;//这样不允许使用new关键字`

+ =0:纯虚函数：无需定义。或者类内声明，类外定义，0只能出现在声明处。

  将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

**default**

default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错

```C++
#include <iostream>
using namespace std;

class CString
{
public:
    CString() = default; //语句1
    //构造函数
    CString(const char* pstr) : _str(pstr){}
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
public:
     string _str;
};


int main()
{
   auto a = new CString(); //语句2
   cout << "Hello World" <<endl;
   return 0;
}
//运行结果
//Hello World



```

如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题

**delete**

delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示

```C++
#include <iostream>
using namespace std;

class CString
{
public:
    void* operator new() = delete;//这样不允许使用new关键字
    //析构函数
    ~CString(){}
};


int main()
{
   auto a = new CString(); //语句1
   cout << "Hello World" <<endl;
   return 0;
}



```

在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法

**0**

将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

> 《C++构造函数的default和delete》：https://blog.csdn.net/u010591680/article/details/71101737



#### 84、智能指针的原理、常用的智能指针及实现

**原理**

+ **智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏**。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

**常用的智能指针**

+  shared_ptr:共享指针，多个指针指向同一个对象，所有指针共同维护一个引用计数器的方法。

+ unique_ptr：独享指针，独享对象，转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空

  + 注意：转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；**所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁**

+  weak_ptr：弱引用

  + 背景：share指针，两个对象互相引用成环的问题，两个对象都无法释放
  + 使用：将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。从这个角度看，weak_ptr更像是shared_ptr的一个助手而不是智能指针。
  + 判断空：如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

+ auto_ptr：自动指针

  + 解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存

    例子：如果该类有2个成员变量，指向两个资源，在构造函数中申请资源A成功，但申请资源B失败，则构造函数失败，那么析构函数不会被调用，那么资源A则泄漏。

    为了解决这个问题，我们可以利用auto_ptr取代普通指针作为成员变量，这样首先调用成功的成员变量的构造函数肯定会调用其析构函数，那么就可以避免资源泄漏问题。

  + 注意：auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题，auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中

**(1) shared_ptr** 

实现原理：采用引用计数器的方法，**允许多个智能指针指向同一个对象**，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

**(2) unique_ptr** 

unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；**所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁**）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

**(3) weak_ptr** 

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。**weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针**，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。

**(4) auto_ptr** 

 主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。

*auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中**。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

**智能指针shared_ptr代码实现：**

```C++
template<typename T>
class SharedPtr
{
public:
	SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
	{}

	SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
		*(_pcount)++;
	}

	SharedPtr<T>& operator=(const SharedPtr& s){
		if (this != &s)
		{
			if (--(*(this->_pcount)) == 0)
			{
				delete this->_ptr;
				delete this->_pcount;
			}
			_ptr = s._ptr;
			_pcount = s._pcount;
			*(_pcount)++;
		}
		return *this;
	}
	T& operator*()
	{
		return *(this->_ptr);
	}
	T* operator->()
	{
		return this->_ptr;
	}
	~SharedPtr()
	{
		--(*(this->_pcount));
		if (this->_pcount == 0)
		{
			delete _ptr;
			_ptr = NULL;
			delete _pcount;
			_pcount = NULL;
		}
	}
private:
	T* _ptr;
	int* _pcount;//指向引用计数的指针
};




```

> 《智能指针的原理及实现》：https://blog.csdn.net/lizhentao0707/article/details/81156384



# 86、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast

总结：

+ reinterpret_cast：重新解释，**这种转换仅仅是对二进制位的重新解释**，不会借助已有的**转换规则**对数据进行调整，非常简单粗暴，所以风险很高。

  + reinterpret_cast<type-id> (expression)
  + type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

+ const_cast：常量

  + const_cast<type_id> (expression)
  + 该运算符用来修改类型的const或volatile属性。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。
  + 用法;
    + 常量指针(引用)被转化成非常量的指针（引用），并且仍然指向原来的对象
    + const_cast一般用于修改底指针。如const char *p形式，使得可以通过p改变对象

+ static_cast:静态转换，这样的转换风险较低，一般不会发生什么意外

  + static_cast < type-id > (expression)

  + 该运算符把expression转换为type-id类型，**在编译期间进行转换，转换失败会抛出编译错误，但没有运行时类型检查来保证转换的安全性**

    + 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换

      ​	进行上行转换（把派生类的指针或引用转换成基类表示）是安全的

      ​	进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的

    + 原有的**自动类型转换**，例如 short 转 int、int 转 double、const 转非 const、向上转型等；

    + void 指针和具体类型指针之间的转换，例如`void *`转`int *`、`char *`转`void *`等；
    + 风险：
      + **两个具体类型指针之间的转换**，例如`int *`转`double *`、`Student *`转`int *`等
      + **int和指针之间转换**，将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件

+ dynamic_cast：动态转换，**用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）**。

  + 向上转型：父类指针指向子类对象。是无条件的，不会进行任何检测，所以都能成功；因为**向上转型始终是安全的**，所以 dynamic_cast **不会进行任何运行期间的检查**，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了
  + 向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。

  + dynamic_cast <type-id> (expression)
    + 该运算符把expression转换成type-id类型的对象。**type-id 必须是类的指针、类的引用或者void***

# 87、C++函数调用的压栈过程

+ 进入main函数时：编译器会将我们**操作系统的运行状态**，**main函数的返回地址**、**main的参数、mian函数中的变量**、进行依次压栈；
+ 调用func()函数时，编译器此时会将**main函数的运行状态进行压栈**，再将**func()函数的返回地址**、func()函数的参数从**右到左、func()定义变量依次压栈；**
+ 当func()调用f()的时候，编译器此时会将**func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈**

从代码入手，解释这个过程：

```C++
#include <iostream>
using namespace std;

int f(int n) 
{
	cout << n << endl;
	return n;
}

void func(int param1, int param2)
{
	int var1 = param1;
	int var2 = param2;
	printf("var1=%d,var2=%d", f(var1), f(var2));//如果将printf换为cout进行输出，输出结果则刚好相反
}

int main(int argc, char* argv[])
{
	func(1, 2);
	return 0;
}
//输出结果
//2
//1
//var1=1,var2=2



```

当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；

当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；

当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈

从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。

> 《C/C++函数调用过程分析》：https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html
>
> 《C/C++函数调用的压栈模型》：https://blog.csdn.net/m0_37717595/article/details/80368411



# 88、说说移动（转换）构造函数

背景：

+ 使用a初始化b，a对象不用，初始化时使用拷贝构造函数，浪费效率，a不用，直接使用a的空间进行初始化。

定义：

+ **以移动而非深拷贝的方式初始化含有指针成员的类对象**。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。 

拷贝构造和移动构造的区别：

+ 对于指针
  + 拷贝构造，使用深拷贝
  + 移动构造使用浅拷贝，将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；

+ 对于参数：
  + 拷贝构造：拷贝构造函数的参数是一个左值引用
  + 动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。

# 89、C++中将临时变量作为返回值时的处理过程

总结：

+ 函数调用时，临时变量被压入栈，函数退出时，临时变量出栈，内存清空
+ 函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了
+ 普通类型可以作为返回值，但是局部指针和引用最好不要作为函数返回值。

首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了

C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit

由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系

如果我们需要返回值，一般使用赋值语句就可以了

> 《【C++】临时变量不能作为函数的返回值？》：https://www.wandouip.com/t5i204349/

（栈上的内存分配、拷贝过程）

# this指针

#### 90、关于this指针你知道什么？全说出来

**特点：**

- this指针是类的指针，指向对象的首地址。

- this指针作为非静态函数的隐式参数只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。

- this指针不是对象的一部分，不会影响sizeof(对象)的结果

**this指针的用处**

+ 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的**非静态成员函数**中访问类的**非静态成员**的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行 

**this指针的使用**

+ **返回对象本身**：一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；

+ **区分参数和成员变量**：另外一种情况是当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n） 



**类的this指针有以下特点**

(1）**this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**成员函数默认第一个参数**为**T * const this**

如：

```C++
class A{
public:
	int func(int p){}
};

```

其中，**func**的原型在编译器看来应该是：

  **int func(A \* const this,int p);**

（2）由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

```C++
A a;
a.func(10);
//此处，编译器将会编译成：
A::func(&a,10);
```

看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。



#### 91、几个this指针的易混问题

**总结：**

+ this指针创建时机：

  + this在成员函数的开始执行前构造，在成员的执行结束后清除。

+ this指针存放位置：

  + this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。

+  this指针是如何传递类中的函数的

  + 大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的

+ this指针是如何访问类中的变量

  + this是类的指针，如果换成结构体，那this就是结构的指针了。

+ 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

  + this指针没有存放在对象内存中，**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）

+ ##### 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

  **普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。**只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰



##### A. this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

##### B. this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

##### C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？

大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

##### D. this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

##### E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

##### F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰

> 《C++中this指针的用法详解》http://blog.chinaunix.net/uid-21411227-id-1826942.html



